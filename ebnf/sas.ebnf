sas: '\n'? exp ('\n' exp)*
block: INDENT ('\n' indent exp)+ DEDENT
exp: if | function | block
function: infix | uatom

blockfix: INDENT ('\n' indent blockop exp)+ DEDENT
infix: (uatom binop)+ (uatom | block)
uatom: (atom atom atom) | (atom atom) | atom
atom:
	| brackets | prefix | identifier | number | text
	| list | set
	| blockfix

list: '[' collection ']'
set: '{' collection '}'
params: '(' collection ')'

collection: INDENT exp? (sep exp)* DEDENT '\n'?
sep: ('\n' indent) | ','

brackets: '(' (block|exp) '\n'? ')'
prefix: unop atom
identifier: SAS-ID
number: NUMBER
text: STRING

unop: '#' | '_' | '^' | '!' | '-' | '+-'
blockop: '+' | '*' | '|' | '&' | '@'
binop:
	| '.'
	| '^' | '_'
	| '*' | '/' | '%'
	| '+' | '-' | '+-'
	| '..'
	| '>' | '<' | '>=' | '<=' | '=' | '!='
	| 'in' | 'as' | ':' | 'is'
	| '|' | '\\' | '&' | 'xor' | 'nor' | 'and' | 'or'
	| '>>' | '<<' | '@' | '->' 
	| '=>' | '<=>'

; IF
; inline if bestaat ff niet

newline: '\n'
if: ruleif | blockif
ruleif:
	'if' block newline
	'then' block
	(newline 'else' INDENT block DEDENT)?
; moet hier end bij?

blockif:
	'if' exp block
	(newline 'elseif' exp block)*
	(newline 'else' block)?

inlineif:
	'if' exp 'then' exp 'else' exp 'end'?

###
sas: '\n'? exp ('\n' exp)*
block: INDENT ('\n' indent exp)+ DEDENT
exp: if | function | block
;sas: block
;block: '\n'? indent exp ('\n' indent exp)*
;exp: if | function; | (INDENT block DEDENT)

blockop: '+' | '*' | '|' | '&' | '@'

function: blockfix | infix | prefix | ufun | atom
suffix: binop (ufun | atom)
prefix: unop atom
blockfix: INDENT ('\n' indent blockop exp)+ DEDENT
infix: atom binop exp
ufix: atom atom ;ufun (binop atom)*
atom:
	| brackets | prefix | identifier | number | text
	| list | set
;	| ablock | blockfix
ablock: INDENT ('\n' indent exp)+ DEDENT

ufun: ufix | uatom
ufix: uatom binop exp
uatom: infun | prefun | atom
infun: atom atom atom
prefun: atom atom
suffun: atom atom

brackets: '(' exp ')'
text: STRING
number: NUMBER
keyword:
	| 'if' | 'else' | 'elseif'
	| 'as' | 'is' | 'in' | 'and' | 'or' | 'xor'
identifier: SAS-ID

list: '[' collection ']'
set: '{' collection '}'
params: '(' collection ')'

collection: INDENT exp? (sep exp)* DEDENT '\n'?
sep: ('\n' '\t') | ','

; INLINEIF tijdelijk uitgeschakeld
newline: '\n'
if: ruleif | blockif
ruleif:
	'if' newline INDENT block DEDENT newline
	'then' INDENT newline block DEDENT
	(newline 'else' newline INDENT block DEDENT)?
; moet hier end bij?
;	('elseif' newline INDENT block DEDENT newline)*

blockif:
	'if' exp newline INDENT block DEDENT
	(newline 'elseif' exp newline INDENT block DEDENT newline)*
	(newline 'else' newline INDENT block DEDENT)?

inlineif:
	'if' exp 'then' exp 'else' exp 'end'?


unop: '#' | '_' | '^' | '!' | '-' | '+-'
binop:
	| '.'
	| '^' | '_'
	| '*' | '/' | '%'
	| '+' | '-' | '+-'
	| '..'
	| '>' | '<' | '>=' | '<=' | '=' | '!='
	| 'in' | 'as' | ':' | 'is'
	| '|' | '\\' | '&' | 'xor' | 'nor' | 'and' | 'or'
	| '>>' | '<<' | '@' | '->' 
	| '=>' | '<=>'

###
sas: exp
exp: function | atom

number: NUMBER
identifier: IDENTIFIER
text: STRING
function: binfunc | unfunc

binfunc: binopfunc | binuserfunc binuserfunc: atom atom atom
binopfunc: unfunc (binop unfunc)+ ; binaire functie

unopfunc: (unop unfunc)
unfunc1: (unop unfunc) | (identifier identifier)
unuserfunc: atom atom
unfunc1: unopfunc | unuserfunc
unfunc: unuserfunc | unopfunc | atom

block: ('\n'? indent exp) ('\n' indent exp)*
atom:
	| identifier | DEBUG | number | text | brackets
	| list | set
brackets: '(' exp ')'
binop:
	| '.'
	| '^' | '_'
	| '*' | '/' | '%'
	| '+' | '-' | '+-'
	| '..'
	| '>' | '<' | '>=' | '<=' | '=' | '!='
	| 'in' | 'as' | ':' | 'is'
	| '|' | '\\' | '&' | 'xor' | 'nor' | 'and' | 'or'
	| '>>' | '<<' | '@' | '->' 
	| '=>' | '<=>'
unop: '#' | '_' | '^' | '!' | '-' | '+' | '+-'

list: '[' collection ']'
set: '{' collection '}'

collection: INDENT exp? (sep exp)* DEDENT '\n'?
sep: ('\n' '\t') | ','

;collection: INDENT sep? (item sep)* item? DEDENT 
;linesep: '\n' indent?
;sep: linesep | (',' linesep?)
;item: atom

a : :
	| list | set | if | function
	| identifier | number | text | data
	| '(' exp ')' | logicblock

identifier: IDENTIFIER
text: STRING
logicblock: INDENT (indent exp newline)* DEDENT
linesep: eol indent
sep: linesep | (',' linesep?)
collection: INDENT sep? (item sep)* item? DEDENT 
item: exp
setcollection: INDENT sep? (item sep)* elseitem? DEDENT 
elseitem: 'else' '->' exp

list: '[' collection ']'
set: '{' setcollection '}'
arguments: '(' collection ')'

if: ruleif | blockif | inlineif
ruleif:
	'if' newline block
	'then' newline block
	('elseif' newline block)*
	('else' newline block)?

blockif:
	'if' exp 'then'? newline block
	('elseif' newline block)*
	('else' newline block)?

inlineif:
	'if' exp 'then' exp 'else' exp 'end'?

; functies
function: infix | prefix | blockfix
unop: '#' | '_' | '^' | '!' | '-' | '+' | '+-'
binop:
	| '.'
	| '^' | '_'
	| '*' | '/' | '%'
	| '+' | '-' | '+-'
	| '..'
	| '>' | '<' | '>=' | '<=' | '=' | '!='
	| 'in' | 'as' | ':' | 'is'
	| '|' | '\\' | '&' | 'xor' | 'nor' | 'and' | 'or'
	| '>>' | '<<' | '@' | '->' 
	| '=>' | '<=>'
prefix: unop (exp | arguments)
infix: (exp binop exp) | blockfix
blockfix:
	INDENT
	newline
	(indent BINOP exp newline)+
	DEDENT

parameters: pureexp | arguments
userfunction: (identifier parameters) | (pureexp identifier parameters)
