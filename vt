#!/usr/bin/lua
package.path = package.path .. ";../?.lua"
require 'exp'
require 'rapporteer-syntax'
require 'bieb'

function boompairs(exp)
	local t = {}
	function r(exp)
		if isatoom(exp) then
			t[exp] = true
		else
			t[exp] = true
			r(exp.fn)
			for i,v in ipairs(exp) do
				r(v)
			end
		end
	end
	r(exp)
	
	local k = nil
	return function()
		if next(t,k) then
			k = next(t,k)
			return k
		end
	end
end

require 'getopt'
require 'lisp'

require 'vertaal'
require 'doe'
require 'naarlua'
require 'rapport'

local opt,bronnen = getopt({...}, "u")

for i,bron in pairs(bronnen) do
	if bron:sub(-5) ~= '.code' then
		bronnen[i] = bron .. '.code'
	end
end

if #bronnen == 0 then
	print('geen invoer')
end

if opt.h or opt.help or #bronnen == 0 then
	print(
[[gebruik: vt [OPTIES...] [BESTANDEN...]
Vertaalt broncode naar applicaties.
Opties:
    -h, --help        print deze hulp
    -d, --doe         voer meteen uit
    -s, --syntax 	  	print syntax
    -L, --lua         genereer lua
    -l, --lokale=CC	  stel lokale van broncode in (standaard NL)
    -u, --uitvoer=UIT	uitvoerbestand
    -v, --verboos     spraakzaam zijn
    -r, --rapport     genereer rapport
]])
	return
end

if opt.v or opt.verboos then
	verboos = true
end

if opt.s or opt.syntaxis then
	verboos = true
end

local ok,code = pcall(file, bronnen[1])
if not ok then print('bestand '..bronnen[1]..' niet gevonden') ; return end

-- rapporteer proces
if opt.r or opt.rapport then
	local html = rapport(code)
	file('rapport.html', html)
end

--local plan = vertaal(code, 'in', 'uit')

local asb = ontleed(code)

-- annoteer ^_^
local i = 1
for t in boompairs(asb) do
	t.i = i
	i = i + 1
	--io.write(t.i..': '..exp2string(t), ' ')
end

if verboos then
	print('ASB')
	print(exp2string(asb))
	print()
end
for exp in boompairs(asb) do
	if exp == 'fout' then
		print('syntaxfout')
		print(asb)
	end
end
assert(asb, 'syntaxfout')
--local stduit,fout,exp2naam0 = oplos(asb, 'standaarduitvoer')

local stduit,fout,bekend,exp2naam = oplos(asb, 'uit')
if not stduit then io.stderr:write('oplosfout: '..tostring(fout)) end
local plan = stduit

-- syntaxrapport
if verboos then
	-- converteer van atoom naar string
	for k,v in pairs(bekend) do if isatoom(k) and k.v then bekend[k.v] = true end end
	for k,v in pairs(bieb) do bekend[k] = true end
	local label = {}
	local klasse = {}
	for t in boompairs(asb) do

		if isatoom(t) and exp2naam and exp2naam[t.v] then
			label[t] = leed(exp2naam[t.v])
		end
		
		if not bekend[t.v] and isvar(t) then klasse[t] = 'fout' end
		if bekend[t.v] then klasse[t] = 'goed' end
	end
	local html = rapporteer_syntax(code,label,klasse)
	file('syntax.html', html)
	print('syntaxrapport weggeschreven naar syntax.html')
end

local uit
if opt.d or opt.doe then
	local v = doe(plan)
	if type(v) ~= 'table' then uit = tostring(toexp(v)) --'<ongeldig type>'
	else
		uit = string.char(table.unpack(v))
	end
else
	--uit = bouw(plan)
	if opt.l or opt.lua then
		uit = naarlua(plan)
	else
		uit = tostring(exp2string(plan or X'?'))..'\n'
	end
end
--uit = unlisp(uit)

local u = opt.u or opt.uitvoer
if u then
	file(u, uit)
else
	io.write(uit)
end
