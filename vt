#!/usr/bin/lua
package.path = package.path .. ";../?.lua"
require 'exp'
require 'rapporteer-syntax'
require 'bieb'

require 'getopt'
require 'lisp'

require 'naarlua'
require 'naarweb'
require 'rapport'
require 'typeer'

require 'bouw.controle'
require 'bouw.kijkgat'
require 'bouw.codegen'
require 'bouw.assembleer'
require 'bouw.elf'

local opt,bronnen = getopt({...}, "u")

for i,bron in pairs(bronnen) do
	if bron:sub(-5) ~= '.code' then
		bronnen[i] = bron .. '.code'
	end
end

if #bronnen == 0 then
	print('geen invoer')
end

if opt.h or opt.help or #bronnen == 0 then
	print(
[[gebruik: vt [OPTIES...] [BESTANDEN...]
Vertaalt broncode naar applicaties.
Opties:
    -h, --help        print deze hulp
    -d, --doe         voer meteen uit
    -s, --syntax 	  	print syntax
    -l, --lua         genereer lua
		-w, --web					genereer webcomponent
    -t, --tekening		uitvoer is tekening
    -l, --lokale=CC	  stel lokale van broncode in (standaard NL)
    -u, --uitvoer=UIT	uitvoerbestand
    -v, --verboos     spraakzaam zijn
    -r, --rapport     genereer rapport
]])
	return
end

bronnen[#bronnen+1] = 'bieb/wisk.code'
bronnen[#bronnen+1] = 'bieb/x64.code'
--bronnen[#bronnen+1] = 'bieb/linux-syscalls.code'

if opt.v or opt.verboos then
	verboos = true
end

if opt.t or opt.tekening then
	tekening = true
end

if opt.s or opt.syntaxis then
	verboos = true
end

local codes = {}
local asb = {fn=X'EN'}

for i,bron in ipairs(bronnen) do
	local ok,code = pcall(file, bron)
	if not ok or not code then print('bestand '..bronnen[1]..' niet gevonden') ; return end
	--codes[bron] = code

	local sub = ontleed(code)
	for i,eq in ipairs(sub) do
		eq.bron = bronnen[1]
		eq.code = code
		asb[#asb+1] = eq
	end
end


-- annoteer ^_^
local i = 1
for t in boompairs(asb) do
	t.i = i
	i = i + 1
	--io.write(t.i..': '..exp2string(t), ' ')
end

if verboos then
	print('ASB')
	print(exp2string(asb))
	print()
end
for exp in boompairs(asb) do
	if exp == 'fout' then
		print('syntaxfout')
		print(asb)
	end
end
assert(asb, 'syntaxfout')

-- typeer!
local types,fouten = typeer(asb)

if #fouten > 0 then
	-- TODO print
	--return
end

local doel = "stduit"
if tekening then doel = "tekening" end

local inn = { "bestanden-in", "udp-in", "tcp-in" }
local uit = { "uit" }

local uit,fouten,exp2naam = oplos(asb, "uit")

if not uit then
	for i, fout in ipairs(fouten) do
		print(fout.msg)
	end
	return
end

local maakvar = maakvars()
local cfg = controle(uit, maakvar)

for blok in pairs(cfg.punten) do
	blok.stats.fn = X'EN'
	print(exp2string(blok.stats))
	blok.stats = kijkgat(blok.stats, maakvar)
end
local asm = codegen(cfg)
file('a.s', asm)
print(asm)
local elf = elf(assembleer(asm))
file('a.elf', elf)
os.execute('chmod +x a.elf')

-- syntaxrapport
if false and verboos then
	-- converteer van atoom naar string
	for k,v in pairs(bekend) do if isatoom(k) and k.v then print('BEKEND IS', k.v); bekend[k.v] = true end end
	for k,v in pairs(bieb) do bekend[k] = true end
	local label = {}
	local klasse = {}
	for t in boompairs(asb) do

		-- opgelost
		if false and isatoom(t) and exp2naam and exp2naam[t.v] then
			label[t] = combineer(exp2naam[t.v])
		end
		
		-- type
		if types[t] or biebtypes[t] then
			if isatoom(t) then
				local bt = biebtypes[exphash(t)]
				label[t] = combineer(types[t] or bt)
				print(loctekst(t.loc), label[t])
			end
		end
		
		klasse[t] = 'fout'
		if not bekend[t.v] then klasse[t] = 'fout' end
		if bekend[t.v] then klasse[t] = 'goed' end
	end
	local html = rapporteer_syntax(code,label,klasse)
	file('syntax.html', html)
	print('syntaxrapport weggeschreven naar syntax.html')
end

--- ACTIE GEDEELTE

if opt.w or opt.web then
	uit = naarweb(uit)

	if opt.d or opt.doe then
		local html = opt.u or opt.uit or 'a.html'
		file(html, uit)
		os.execute("firefox "..html)
	else
		print(uit)
	end

	return
end

if opt.d or opt.doe then
	--local v = doe(uit)
	local luacode = naarlua(uit)
	local fn,fout = load(luacode)
	if not fn then
		print(fout)
		file('code.log', luacode)
		print('luacode weggeschreven naar code.log')
		return
	end

	local socket = require 'socket'
	while true do
		socket.sleep(0.01)
		local ok,fout = xpcall(fn, debug.traceback)
		if not ok then
			print(fout)
			file('code.log', luacode)
			print('luacode weggeschreven naar code.log')
			return
		end

		v = fout -- niet
		if type(v) ~= 'table' then
			uit = tostring(combineer(v)) --'<ongeldig type>'
		else
			uit = string.char(table.unpack(v))
		end
		break
		--io.write('\x1B[F', '\x1B[G', uit, '\x1B[K', '\n')
	end

else
	if opt.l or opt.lua then
		uit = naarlua(uit)
	
	-- zonder opties
	elseif uit then
		--uit = bouw(uit)
		uit = exp2string(uit)
	end
end
--uit = unlisp(uit)

local u = opt.u or opt.uitvoer
if u then
	file(u, uit)
else
	io.write(uit)
end
