#!/usr/bin/lua
package.path = package.path .. ";../?.lua"
require 'exp'
require 'rapporteer-syntax'
require 'bieb'

require 'getopt'
require 'lisp'

require 'naarlua'
require 'naarweb'
require 'rapport'
require 'typeer'

require 'bouw.controle'
require 'bouw.kijkgat'
require 'bouw.codegen'
require 'bouw.assembleer'
require 'bouw.elf'

local opt,bronnen = getopt({...}, "u")

for i,bron in pairs(bronnen) do
	if bron:sub(-5) ~= '.code' then
		bronnen[i] = bron .. '.code'
	end
end

if #bronnen == 0 then
	print('geen invoer')
end

bronnen[#bronnen+1] = 'bieb/unistd.code'

if opt.h or opt.help or #bronnen == 0 then
	print(
[[gebruik: vt [OPTIES...] [BESTANDEN...]
Vertaalt broncode naar applicaties.
Opties:
    -h, --help        print deze hulp
    -v, --verboos     meer uitvoer
    -g, --debug       genereer ontkeverinformatie
    -d, --doe         voer meteen uit
    -l, --lokale=CC	  stel lokale van broncode in (standaard NL)
    -u, --uitvoer=UIT	uitvoerbestand

    -S                genereer assembly-code
    -R                genereer uitgebreid rapport

    -A                print syntaxinformatie
    -G                print kennisgraaf
    -K                print voorgekauwde (opgeloste) kennis

    -O                print oplosinformatie
    -W                print opgeloste waarde (GENERIEK AS FUCK!)

    -T                print types
    -Y                print typegraaf

    -D                print delta-tijd informatie
    -C                print de controlegraaf

    -I                print intermediaire code
    -J                print kijkgat code

    -F                print uitvoer na kijkgatoptimalisaties
    -G                print assemblycode
    -H                print linker info
    -M                print geheugenallocatie info
    -B                print broncode
    -r, --rapport     genereer rapport
]])
	return
end

--bronnen[#bronnen+1] = 'bieb/wisk.code'
--bronnen[#bronnen+1] = 'bieb/x64.code'
--bronnen[#bronnen+1] = 'bieb/linux-syscalls.code'

if opt.d or opt.doe then
	doemeteen = true
end
if opt.v or opt.verboos then
	verboos = true
end

if opt.R then verbozeRapport = true end
if opt.S then verbozeSyntax = true end
if opt.D then verbozeDeductie = true end
if opt.K then verbozeKennis = true end
if opt.G then verbozeKennisgraaf = true end
if opt.W then verbozeWaarde = true end
if opt.D then verbozeDelta = true end
if opt.C then verbozeControle = true end
if opt.I then verbozeIntermediair = true end
if opt.J then verbozeKijkgat = true end
if opt.A then verbozeAsm = true end
if opt.H then verbozeLinker = true end
if opt.M then verbozeOpslag = true end
if opt.B then verbozeBroncode = true end

if opt.T then verbozeTypes = true end
if opt.Y then verbozeTypegraaf = true end

if opt.g or opt.debug or opt.ontkever then
	ontkever = true
end

if opt.t or opt.tekening then
	tekening = true
end

if opt.s or opt.syntaxis then
	verboos = true
end

local codes = {}
local asb = {fn=X'EN'}

if verbozeBroncode then
	print('=== BRONCODE ===')
end
for i,bron in ipairs(bronnen) do
	local ok,code = pcall(file, bron)
	if verbozeBroncode then
		print('== '..bron..' ==')
		print(code)
	end
	if not ok or not code then print('bestand '..bronnen[1]..' niet gevonden') ; return end
	--codes[bron] = code

	local sub = ontleed(code, bron)
	for i,eq in ipairs(sub) do
		eq.bron = bronnen[1]
		eq.code = code
		asb[#asb+1] = eq
	end
end
if verbozeBroncode then
	print()
end

-- annoteer ^_^
local i = 1
for t in boompairs(asb) do
	t.i = i
	i = i + 1
	--io.write(t.i..': '..exp2string(t), ' ')
end

if verbozeSyntax then
	print('=== SYNTAXBOOM ===')
	print(exp2string(asb))
	print()
end
for exp in boompairs(asb) do
	if exp == 'fout' then
		print('syntaxfout')
		print(asb)
	end
end
assert(asb, 'syntaxfout')

-- typeer!
--local function gekleurd(x, kleur)
local types,fouten = typeer(asb)

if #fouten > 0 then
	for i,fout in ipairs(fouten) do
		if fout.loc.bron:sub(1,4) ~= 'bieb' then
			print(fout.msg)
		end
	end
	-- TODO print
	--return
end

local doel = "stduit"
if tekening then doel = "tekening" end

local inn = { "bestanden-in", "udp-in", "tcp-in" }
local uit = { "uit" }

local uit,fouten,exp2naam = oplos(asb, "uit")

if not uit then
	if not fouten[1] then
		print('kon niet oplossen')
		return
	end
	for i, fout in ipairs(fouten) do
		print(fout.msg)
	end
	return
end

-- opgelost!
if verbozeOplos then
	print('=== TIJDLOOS ===')
	print(exp2string(uit))
	print()
end
local maakvar = maakvars()
local cfg = controle(uit, maakvar)

if verbozeControle then
	print('=== CONTROLEGRAAF ===')
	print(cfg)
	print()
end

if verbozeIntermediair then
	print('=== INTERMEDIAIRE CODE ===')
	for blok in spairs(cfg.punten) do
		print(blok)
	end
	print()
end

for blok in pairs(cfg.punten) do
	--blok.stats.fn = X'EN'
	--print(exp2string(blok.stats))
	blok.stats = kijkgat(blok.stats, maakvar)
end

if verbozeKijkgat then
	print('=== KIJKGAT CODE ===')
	for blok in spairs(cfg.punten) do
		print(blok)
	end
	print()
end

local asm = codegen(cfg)
if opt.S then
	--file('a.s', asm)
end
local elf = elf(assembleer(asm, 'a'), 'a')
os.execute('chmod +x a.elf')
if doemeteen then
	print('== START ==')
	os.execute('./a.elf')
end

