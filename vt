#!/usr/bin/luajit
package.path = package.path .. ";../?.lua"
require 'exp'
require 'rapporteer-syntax'
require 'bieb'

require 'getopt'
require 'lisp'
require 'vertolk'

require 'rapport'
require 'typeer'
require 'doe'
require 'optimaliseer'
require 'oplos'

require 'bouw.genjs'
require 'bouw.genx64'

require 'bouw.arch'
require 'bouw.codegen'
require 'bouw.assembleer'
require 'bouw.link'

-- installeer profiler
local aantal = {}
local D = debug.getinfo
function trace()
	local info = D(2, "Sl")
	local loc = info.source .. "@" .. info.currentline
	local a = aantal[loc]
	if not a then
		aantal[loc] = 1
	else
		aantal[loc] = a + 1
	end
end
--debug.sethook(trace, "l")

opt,bronnen = getopt({...}, "u")

for i,bron in pairs(bronnen) do
	if bron:sub(-5) ~= '.code' then
		bronnen[i] = bron .. '.code'
	end
end

if #bronnen == 0 then
	print('geen invoer')
end

if opt.h or opt.help or #bronnen == 0 then
	print(
[[gebruik: vt [OPTIES...] [BESTANDEN...]
Vertaalt broncode naar applicaties.
Opties:
    -h, --help        print deze hulp
    -v, --verboos     meer uitvoer
    -g, --debug       genereer ontkeverinformatie
    -d, --doe         voer meteen uit
    -l, --lokale=CC	  stel lokale van broncode in (standaard NL)
    -u, --uitvoer=UIT	uitvoerbestand

    -i, --veilig      draai het programma in veilige modus
    -j,	--javascript	compileer naar javascript
    -x,	--demo				compileer naar demo
		
    -O								optimaliseer uitvoer

    -S                genereer assembly-code
    -R                genereer uitgebreid rapport

    -B                print syntaxinformatie
    -R                print architectuurspecifieke boom
    -G                print kennisgraaf
    -K                print voorgekauwde (opgeloste) kennis

    -Q                print oplosinformatie
    -W                print opgeloste waarde (GENERIEK AS FUCK!)

    -T                print types
    -Y                print typegraaf

    -D                print delta-tijd informatie
    -C                print de controlegraaf

    -I                print intermediaire code
    -J                print kijkgat code
    -L                print elke uitgevoerde instructie

    -F                print uitvoer na kijkgatoptimalisaties
    -A                print assemblycode
    -H                print linker info
    -M                print geheugenallocatie info
    -B                print broncode
    -r, --rapport     genereer rapport
]])
	return
end

--bronnen[#bronnen+1] = 'bieb/wisk.code'
--bronnen[#bronnen+1] = 'bieb/x64.code'
--bronnen[#bronnen+1] = 'bieb/linux-syscalls.code'

local doel
if opt.j then doel = 'demo'
elseif opt.i then doel = 'lua'
elseif opt.x then doel = 'demo'
else doel = 'unistd' end

bronnen[#bronnen+1] = 'bieb/'..doel..'.code'

if opt.d or opt.doe then
	doemeteen = true
end
if opt.v or opt.verboos then
	verboos = true
end
if opt.j then opt.javascript = true end

if opt.R then verbozeRapport = true end
if opt.S then verbozeSyntax = true end
if opt.D then verbozeDeductie = true end
if opt.K then verbozeKennis = true end
if opt.Q then verbozeOplos = true end
if opt.G then verbozeKennisgraaf = true end
if opt.W then verbozeWaarde = true end
if opt.D then verbozeDelta = true end
if opt.C then verbozeControle = true end
if opt.I then verbozeIntermediair = true end
if opt.J then verbozeKijkgat = true end
if opt.A then verbozeAsm = true end
if opt.H then verbozeLinker = true end
if opt.M then verbozeOpslag = true end
if opt.B then verbozeBroncode = true end

if opt.T then verbozeTypes = true end
if opt.Y then verbozeTypegraaf = true end
if opt.i then opt.veilig = true end

if opt.g or opt.debug or opt.ontkever then
	opt.g = true
	ontkever = true
end

if opt.t or opt.tekening then
	tekening = true
end

if opt.s or opt.syntaxis then
	verboos = true
end

local codes = {}
local asb = {f=X'â‹€',a={o=X'[]'}}

if verbozeBroncode then
	print('=== BRONCODE ===')
end
for i,bron in ipairs(bronnen) do
	local ok,code = pcall(file, bron)
	if verbozeBroncode then
		print('== '..bron..' ==')
		print(code)
	end
	if not ok or not code then print('bestand '..bronnen[1]..' niet gevonden') ; return end
	--codes[bron] = code

	local sub,fouten = ontleed(code, bron)
	sub = sub or X'nee'
	for i,fout in ipairs(fouten) do
		print(fout2ansi(fout))
	end
	for i,eq in ipairs(sub.a) do
		eq.bron = bronnen[1]
		eq.code = code
		asb.a[#asb.a+1] = eq
	end
end

if verbozeSyntax then
	print()
	print('=== SYNTAX ===')
	print(e2s(asb))
	print()
end

-- lekker checken
check(asb)

-- annoteer ^_^
local i = 1
for t in boompairs(asb) do
	t.i = i
	i = i + 1
	--io.write(t.i..': '..exp2string(t), ' ')
end

-- vertolk
if opt.lang == 'en' then
	asb = vertolk(asb)
end

if verbozeSyntax then
	print('=== SYNTAXBOOM ===')
	print(exp2string(asb))
	print()
end
for exp in boompairs(asb) do
	if exp == 'fout' then
		print('syntaxfout')
		print(asb)
	end
end
assert(asb, 'syntaxfout')

-- machinespecifieke typechecker
local t,fouten = typeer(asb)

local mach = arch.x64(asb, t)
if opt.R then
	print('=== ARCH ===')
	print(e2s(mach))
end

-- typeer!
--local function gekleurd(x, kleur)
local types,fouten0 = typeer(mach)

if #fouten > 0 then
	local exit = false
	for i,fout in ipairs(fouten) do
		if not fout.loc.bron or fout.loc.bron:sub(1,4) ~= 'bieb' then
			print(fout2ansi(fout))
			exit = true
		end
	end
	-- TODO print
	if exit then
		--return
	end
end


if opt.O then
	mach = optimaliseer(mach)
end
local uit,fouten,exp2naam = oplos(mach, "app")

if not uit then
	if not fouten[1] then
		print('kon niet oplossen voor "app"')
		return
	end
	for i, fout in ipairs(fouten) do
		print(fout2ansi(fout))
	end
	return
end

-- expressie fase: optm
if opt.O then
	uit = optimaliseer(uit)
	--print(taal2string(uit))
	--return
end

-- control flow!
local maakvar = maakvars()
local cfg = codegen(uit, maakvar)

if verbozeControle then
	print('=== CONTROLEGRAAF ===')
	print(cfg)
	print()
end

if verbozeIntermediair then
	print('=== INTERMEDIAIRE CODE ===')
	print(cfg.start)
	for blok in spairs(cfg.punten) do
		if blok ~= cfg.start then
			print(blok)
		end
	end
	print()
end

-- nieuwe lage JS
if opt.javascript then
	uit = genjs(cfg)
	debug.sethook()
	local t = {}
	for i=1,10 do
		local max = 0
		local maxloc = 'a'
		for loc, num in pairs(aantal) do
			if num > max then
				maxloc = loc
				max = num
			end
		end
		--print('trace', maxloc, max)
		aantal[maxloc] = nil
	end

	file('a.js', uit)
	print(uit)
	if opt.d then
		os.execute('js a.js')
	end
	return
end


if opt.i or opt.veilig then
	if opt.L then
		print('=== START ===')
	end
	local exp = doe(cfg)
	if verbozeIntermediair then
		print()
	end
	return
end
	

for blok in pairs(cfg.punten) do
	--blok.stats.fn = X'EN'
	--print(exp2string(blok.stats))
	--blok.stats = kijkgat(blok.stats, maakvar)
end

if verbozeKijkgat then
	print('=== KIJKGAT CODE ===')
	for blok in spairs(cfg.punten) do
		print(blok)
	end
	print()
end

local asm = genx64(cfg)
if opt.S then
	--file('a.s', asm)
end
local elf = link(assembleer(asm, 'a'), 'a')
file('a.elf', elf)
os.execute('chmod +x a.elf')
if doemeteen then
	print('== START ==')
	os.execute('./a.elf')
end
