#!/usr/bin/lua
package.path = package.path..';../?.lua'

require 'naarlua'
require 'naarweb'
require 'infix'
require 'rapporteer-syntax'
require 'json'

require 'ontleed'
require 'typeer'
require 'oplos'

local socket = require 'socket'
local server = socket.bind('127.0.0.1','1237')
assert(server)
local sockets = {server}
local coros = {}

local function cat(...)
	local abc = {...}
	local r = {}
	for i,t in ipairs(abc) do
		for i,v in ipairs(t) do	
			r[#r+1] = v
		end
	end
	return r
end

-- DE webfunctie
-- vt: code â†’ {html?, fouten?}
--   fouten: [ fout... ]
--   fout: syntaxfout | typefout | oplosfout
--     syntaxfout: { type="syntax", loc, waarom, waarde }
--       loc: codemirror-locatie
--     typefout: { type="typeer", ? }
--     oplosfout: { type="oplos", ? }
-- 
-- de "fout" als los interpretabel object
function vt(code)
	local exp = ontleed(code)
	exp.code = code
	local syntaxfouten = {}
	for exp in boompairs(exp) do
		if exp.fout then -- TODO niet meer in boom
			local syntaxfout = {
				type = "syntax",
				pos = {
					ch = exp.loc.x1 - 1,
					line = exp.loc.y1 - 1
				},
				waarom = exp.fout,
				waarde = "?",
			}
			syntaxfouten[#syntaxfouten+1] = syntaxfout
		end
	end

	local function jsloc(loc)
		local jloc = {
			anchor = {
				ch = loc.x1 - 1,
				line = loc.y1 - 1,
			},
			head = {
				ch = loc.x2 - 1,
				line = loc.y2 - 1,
			}
		}
		return jloc
	end

	local types,typeerfouten = typeer(exp)
	
	for i=1,#typeerfouten do
		local fout = typeerfouten[i]
		local waarom = fout.msg
		if fout.fmt then
			-- {exp} is {istype} maar moet {moettype} zijn
			-- links is %s, rechts is %s
			local istype = string.format(
				'<span class="loc" onclick=\'selecteer(%s)\'>%s</span>',
				json.encode(isloc),
				fout.istype
			)
			local moettype = '<span class="loc" onclick="selecteer(fout.moetloc)">'..fout.moettype..'</span>'

			waarom = fout.fmt
			waarom = string.gsub(waarom, '{exp}', '<b>'..fout.exp..'</b>')
			waarom = string.gsub(waarom, '{istype}', istype)
			waarom = string.gsub(waarom, '{moettype}', '<b>'..moettype..'</b>')
		end
		waarom = waarom or '<onbekende reden>'
		typeerfouten[i] = {
			type = "typeer",

			pos = {
				ch = fout.loc.x1 - 1,
				line = fout.loc.y1 - 1,
			},

			loc = {
				anchor = {
					ch = fout.loc.x1 - 1,
					line = fout.loc.y1 - 1,
				},
				head = {
					ch = fout.loc.x2 - 1,
					line = fout.loc.y2 - 1,
				}
			},
			exp = fout.exp,
			--exploc = fout.exp.loc,
			waarom = waarom,
			istype = fout.istype,
			moettype = fout.moettype,
			isloc = fout.isloc and jsloc(fout.isloc),
			--moetloc = jsloc(fout.moetloc),
		}
	end

	local waarde,oplosfouten

	local html

	if not typeerfouten or true then
		waarde,oplosfouten = oplos(exp, 'uit')
		if waarde then
			local f = load(naarlua(waarde))
			local ok,v = pcall(f)
			local v = ok and string.char(table.unpack(v)) or '&lt;niets&gt;'
			html = '<pre>'..v..'</pre>'
		else
			waarde,oplosfouten = oplos(exp, 'tekening')
			if waarde then
				html = naarweb(waarde)
			end
		end
	end

	-- foutje kan gebeuren
	local fouten
	if syntaxfouten or typeerfouten or oplosfouten then
		fouten = cat(syntaxfouten, typeerfouten) --, oplosfouten or {})
	end

	return {
		html = html,
		fouten = fouten,
	}
end

local statusberichten = {
	[200] = "Okee",
	[302] = "Permanente Omleiding",
	[404] = "Niet Gevonden",
	[500] = "Interne Fout",
}

function sendblocking(sock, data)
	local i = 1
	while i < #data do
		local len,err = sock:send(data, i, #data)
		if not len then return nil,err end
		i = i + len + 1 -- laatst verzonden byte
	end
	return #data
end

function serveer(sock)
	local len

	-- header
  coroutine.yield()
	local line = sock:receive('*l')
	local methode,pad = line:match("([^ ]*) ([^ ]*) ([^ ]*)")

	while true do
		coroutine.yield()
		local line = sock:receive('*l')
		if line == '' then
			break
		end
		
		local len0 = line:match('Content%-Length: (%d+)')
		if len0 then
			len = tonumber(len0)
		end
	end

	-- content
	local inn
	local uit
	if len then
		coroutine.yield()
		inn = sock:receive(len)
	end

	-- uitvoer, log (in), http statuscode
	local uit, inL, status

	if inn then
		inL = string.format('%q', tostring(inn)):gsub('\n', '\\n')
	end

	-- VERTAAL!
	if pad == '/vt' then
		local internefout
		local ok,j = xpcall(vt, debug.traceback, inn)
		if not ok then internefout = j end

		if not ok then
			print(internefout)
			status = 500
			uit = '<pre>'.."INTERNE FOUT!\n"..internefout..'</pre>'
		else
			status = 200
			uit = json.encode(j) -- json(html, fouten)
		end

	-- LEES!
	else
    pad = pad:gsub('%.%.', '%.')
		if pad == '/' then pad = '/index.html' end
    pad = 'www' .. pad
		uit = file(pad)
		status = 200
		if not uit then
			uit = 'pagina niet gevonden'
			status = 404
		end
	end

	print(os.date(), status, pad, string.sub(inL or '', 1, 20))

	-- header
	local h = string.format('HTTP/1.0 %d %s\r\n', status, statusberichten[status])
	local t = {}
	t[#t+1] = h
	t[#t+1] = "Host: localhost\r\n"
	t[#t+1] = "Server: Lua 5.2\r\n"
	t[#t+1] = "Content-Length: "..#uit.."\r\n"
	t[#t+1] = "\r\n"
	t[#t+1] = uit
	sendblocking(sock, table.concat(t))

	sock:close()
end


-- stop als argumenten!
local veto = ...
if veto then return end

-- os.execute("chromium http://localhost:1237 &")


while true do
	local rs = socket.select(sockets, nil, 0.16) -- rapido

	-- connect
	if rs[1] == server then
		local client = server:accept()
		sockets[client] = #sockets+1
		sockets[#sockets+1] = client
		coros[client] = coroutine.create(serveer, client)
		coroutine.resume(coros[client], client)
		table.remove(rs, 1)
	end

	-- data
	for i=#rs,1,-1 do
		local client = rs[i]
		local coro = coros[client]
		if not coro or coroutine.status(coro) ~= 'suspended' then
			table.remove(sockets, sockets[client]) --client)
			sockets[client] = nil
			coros[client] = nil
		else
			local unfinished,err = coroutine.resume(coros[client])
			if err then print('ERR', err) end
			if not unfinished then
				table.remove(sockets, sockets[client]) --client)
				sockets[client] = nil
				coros[client] = nil
			end
		end
	end

end
