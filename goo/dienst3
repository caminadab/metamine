#!/usr/bin/lua
package.path = package.path..';../?.lua'
require 'ontleed'
require 'oplos'
require 'naarlua'
require 'infix'
require 'rapporteer-syntax'

local socket = require 'socket'
local server = socket.bind('127.0.0.1','1237')
assert(server)
local sockets = {server}
local coros = {}

function boompairs(exp)
	local t = {}
	function r(exp)
		if isatoom(exp) then
			t[exp] = true
		else
			t[exp] = true
			r(exp.fn)
			for i,v in ipairs(exp) do
				r(v)
			end
		end
	end
	r(exp)
	
	local k = nil
	return function()
		if next(t,k) then
			k = next(t,k)
			return k
		end
	end
end

-- DE api functie
function vt(code)
	local asb,fouten = ontleed(code)

local statusberichten = {
	[200] = "OK",
	[404] = "Niet Gevonden",
}

function sendblocking(sock, data)
	local i = 1
	while i < #data do
		local len,err = sock:send(data, i, #data)
		if not len then return nil,err end
		i = i + len + 1 -- laatst verzonden byte
	end
	return #data
end

function serveer(sock)
	local len

	-- header
  coroutine.yield()
	local line = sock:receive('*l')
	local methode,pad = line:match("([^ ]*) ([^ ]*) ([^ ]*)")

	while true do
		coroutine.yield()
		local line = sock:receive('*l')
		if line == '' then
			break
		end
		
		local len0 = line:match('Content%-Length: (%d+)')
		if len0 then
			len = tonumber(len0)
		end
	end

	-- content
	local inn
	local uit
	if len then
		coroutine.yield()
		inn = sock:receive(len)
	end

	function oplosPlus(code,asb)
		local uit,fout,bekend,exp2naam = oplos(asb, 'tekening')
		if not uit then io.stderr:write('oplosfout: '..tostring(fout)) end

		-- syntaxrapport
		for k,v in pairs(bekend) do if isatoom(k) and k.v then print('BEKEND IS', k.v); bekend[k.v] = true end end
		for k,v in pairs(bieb) do bekend[k] = true end
		local label = {}
		local klasse = {}
		for t in boompairs(asb) do

			if isatoom(t) and exp2naam and exp2naam[t.v] then
				label[t] = combineer(exp2naam[t.v])
			end
			
			klasse[t] = 'fout'
			if not bekend[t.v] then klasse[t] = 'fout' end
			if bekend[t.v] then klasse[t] = 'goed' end
		end
		local html = rapporteer_syntax(code,label,klasse)
		return uit,html
	end

	-- vertaal
	local function vt()
		-- type.html, syntax.html, resultaat.html
		local exp,rapport = oplosPlus(inn, ontleed(inn..'\n'))
		require 'naarweb'
		local resultaat = naarweb(exp)
		return rapport,resultaat
	end

	local uit, inL, status
	if pad == '/vt' then
		local ok,a,b = pcall(vt, inn)
		status = 200
		uit = b..a
		inL = string.format('%q', tostring(inn)):gsub('\n', '\\n')
	else
    pad = pad:gsub('%.%.', '%.')
    pad = pad:sub(2, #pad)
		if pad == '' then pad = 'index.html' end
		uit = file(pad)
		status = 200
		if not uit then
			uit = 'pagina niet gevonden'
			status = 404
		end
	end

	print(os.date(), status, pad, inL)

	-- header
	local h = string.format('HTTP/1.0 %d %s\r\n', status, statusberichten[status])
	local t = {}
	t[#t+1] = h
	t[#t+1] = "Host: localhost\r\n"
	t[#t+1] = "Server: Lua 5.2\r\n"
	t[#t+1] = "Content-Length: "..#uit.."\r\n"
	t[#t+1] = "\r\n"
	t[#t+1] = uit
	sendblocking(sock, table.concat(t))

	sock:close()
end

while true do
	local rs = socket.select(sockets)

	-- connect
	if rs[1] == server then
		local client = server:accept()
		sockets[client] = #sockets+1
		sockets[#sockets+1] = client
		coros[client] = coroutine.create(serveer, client)
		coroutine.resume(coros[client], client)
		table.remove(rs, 1)
	end

	-- data
	for i=#rs,1,-1 do
		local client = rs[i]
		local coro = coros[client]
		if not coro or coroutine.status(coro) ~= 'suspended' then
			table.remove(sockets, sockets[client]) --client)
			sockets[client] = nil
			coros[client] = nil
		else
			local unfinished,err = coroutine.resume(coros[client])
			if err then print('ERR', err) end
			if not unfinished then
				table.remove(sockets, sockets[client]) --client)
				sockets[client] = nil
				coros[client] = nil
			end
		end
	end

end
